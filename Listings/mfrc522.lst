C51 COMPILER V9.60.7.0   MFRC522                                                           05/23/2025 10:22:55 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MFRC522
OBJECT MODULE PLACED IN .\Objects\mfrc522.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE mfrc522.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\at89s52_rfid) DEBUG OBJECTE
                    -XTEND PRINT(.\Listings\mfrc522.lst) TABS(2) OBJECT(.\Objects\mfrc522.obj)

line level    source

   1          #include "mfrc522.h"
   2          #include <intrins.h>
   3          
   4          void delay_us(unsigned int us) {
   5   1          while (us--) {
   6   2              _nop_(); // T?o d? tr? nh?, c?n di?u ch?nh d?a trên t?n s? clock
   7   2          }
   8   1      }
   9          
  10          // Hàm SPI bit-banging: G?i và nh?n m?t byte
  11          unsigned char spi_transfer(unsigned char byte) {
  12   1          unsigned char i, received = 0;
  13   1          for(i = 0; i < 8; i++) {
  14   2              if(byte & 0x80) MFRC522_MOSI = 1; else MFRC522_MOSI = 0;
  15   2              MFRC522_SCK = 1;
  16   2              if(MFRC522_MISO) received |= (1 << (7 - i));
  17   2              MFRC522_SCK = 0;
  18   2              byte <<= 1;
  19   2              delay_us(1);  // Delay nh? d? d?m b?o timing
  20   2          }
  21   1          return received;
  22   1      }
  23          
  24          // Hàm ghi vào thanh ghi MFRC522
  25          void mfrc522_write(unsigned char reg, unsigned char value) {
  26   1          MFRC522_CS = 0;
  27   1          spi_transfer((reg << 1) & 0x7E);  // Ð?a ch? ghi, bit 7 = 0
  28   1          spi_transfer(value);
  29   1          MFRC522_CS = 1;
  30   1      }
  31          
  32          // Hàm d?c t? thanh ghi MFRC522
  33          unsigned char mfrc522_read(unsigned char reg) {
  34   1          unsigned char value;
  35   1          MFRC522_CS = 0;
  36   1          spi_transfer(((reg << 1) & 0x7E) | 0x80);  // Ð?a ch? d?c, bit 7 = 1
  37   1          value = spi_transfer(0x00);  // G?i byte dummy d? nh?n d? li?u
  38   1          MFRC522_CS = 1;
  39   1          return value;
  40   1      }
  41          
  42          // Hàm reset MFRC522
  43          void mfrc522_reset(void) {
  44   1          MFRC522_RST = 0;
  45   1          delay_us(10);
  46   1          MFRC522_RST = 1;
  47   1          delay_us(10);
  48   1          mfrc522_write(CommandReg, PCD_RESETPHASE);
  49   1      }
  50          
  51          // Hàm kh?i t?o MFRC522
  52          void mfrc522_init(void) {
  53   1          MFRC522_CS = 1;
  54   1          MFRC522_SCK = 0;
C51 COMPILER V9.60.7.0   MFRC522                                                           05/23/2025 10:22:55 PAGE 2   

  55   1          MFRC522_MOSI = 0;
  56   1          mfrc522_reset();
  57   1          
  58   1          // Thi?t l?p các thanh ghi
  59   1          mfrc522_write(TModeReg, 0x8D);
  60   1          mfrc522_write(TPrescalerReg, 0x3E);
  61   1          mfrc522_write(TReloadRegL, 30);
  62   1          mfrc522_write(TReloadRegH, 0);
  63   1          mfrc522_write(TxASKReg, 0x40);
  64   1          mfrc522_write(ModeReg, 0x3D);
  65   1          
  66   1          // B?t anten
  67   1          mfrc522_write(TxControlReg, mfrc522_read(TxControlReg) | 0x03);
  68   1      }
  69          
  70          // Hàm yêu c?u th?
  71          unsigned char mfrc522_request(unsigned char req_mode, unsigned char *tag_type) {
  72   1          unsigned char status;
  73   1          unsigned int back_bits;
  74   1          mfrc522_write(BitFramingReg, 0x07);
  75   1          tag_type[0] = req_mode;
  76   1          status = mfrc522_to_card(PCD_TRANSCEIVE, tag_type, 1, tag_type, &back_bits);
  77   1          if((status != MI_OK) || (back_bits != 0x10)) {
  78   2              status = MI_ERR;
  79   2          }
  80   1          return status;
  81   1      }
  82          
  83          // Hàm ch?ng va ch?m (anticollision)
  84          unsigned char mfrc522_anticoll(unsigned char *serNum) {
  85   1          unsigned char status;
  86   1          unsigned char i;
  87   1          unsigned char serNumCheck = 0;
  88   1          unsigned int unLen;
  89   1          mfrc522_write(BitFramingReg, 0x00);
  90   1          serNum[0] = PICC_ANTICOLL;
  91   1          serNum[1] = 0x20;
  92   1          status = mfrc522_to_card(PCD_TRANSCEIVE, serNum, 2, serNum, &unLen);
  93   1          if(status == MI_OK) {
  94   2              for(i = 0; i < 4; i++) {
  95   3                  serNumCheck ^= serNum[i];
  96   3              }
  97   2              if(serNumCheck != serNum[4]) {
  98   3                  status = MI_ERR;
  99   3              }
 100   2          }
 101   1          return status;
 102   1      }
 103          
 104          // Hàm giao ti?p v?i th?
 105          unsigned char mfrc522_to_card(unsigned char cmd, unsigned char *send_data, unsigned char send_len, unsigne
             -d char *back_data, unsigned int *back_len) {
 106   1          unsigned char status = MI_ERR;
 107   1          unsigned char irqEn = 0x00;
 108   1          unsigned char waitIRq = 0x00;
 109   1          unsigned char lastBits;
 110   1          unsigned char n;
 111   1          unsigned int i;
 112   1          
 113   1          switch(cmd) {
 114   2              case PCD_TRANSCEIVE:
 115   2                  irqEn = 0x77;
C51 COMPILER V9.60.7.0   MFRC522                                                           05/23/2025 10:22:55 PAGE 3   

 116   2                  waitIRq = 0x30;
 117   2                  break;
 118   2              default:
 119   2                  break;
 120   2          }
 121   1          
 122   1          mfrc522_write(ComIEnReg, irqEn | 0x80);
 123   1          mfrc522_write(ComIrqReg, 0x7F);
 124   1          mfrc522_write(CommandReg, PCD_IDLE);
 125   1          mfrc522_write(FIFOLevelReg, 0x80);
 126   1          
 127   1          for(i = 0; i < send_len; i++) {
 128   2              mfrc522_write(FIFODataReg, send_data[i]);
 129   2          }
 130   1          
 131   1          mfrc522_write(CommandReg, cmd);
 132   1          
 133   1          if(cmd == PCD_TRANSCEIVE) {
 134   2              mfrc522_write(BitFramingReg, mfrc522_read(BitFramingReg) | 0x80);
 135   2          }
 136   1          
 137   1          i = 2000;
 138   1          do {
 139   2              n = mfrc522_read(ComIrqReg);
 140   2              i--;
 141   2          } while((i != 0) && !(n & 0x01) && !(n & waitIRq));
 142   1          
 143   1          mfrc522_write(BitFramingReg, mfrc522_read(BitFramingReg) & (~0x80));
 144   1          
 145   1          if(i != 0) {
 146   2              if(!(mfrc522_read(ErrorReg) & 0x1B)) {
 147   3                  status = MI_OK;
 148   3                  if(n & irqEn & 0x01) {
 149   4                      status = MI_NOTAGERR;
 150   4                  }
 151   3                  if(cmd == PCD_TRANSCEIVE) {
 152   4                      n = mfrc522_read(FIFOLevelReg);
 153   4                      lastBits = mfrc522_read(ControlReg) & 0x07;
 154   4                      if(lastBits) {
 155   5                          *back_len = (n - 1) * 8 + lastBits;
 156   5                      } else {
 157   5                          *back_len = n * 8;
 158   5                      }
 159   4                      if(n == 0) {
 160   5                          n = 1;
 161   5                      }
 162   4                      if(n > 16) {
 163   5                          n = 16;
 164   5                      }
 165   4                      for(i = 0; i < n; i++) {
 166   5                          back_data[i] = mfrc522_read(FIFODataReg);
 167   5                      }
 168   4                  }
 169   3              } else {
 170   3                  status = MI_ERR;
 171   3              }
 172   2          }
 173   1          
 174   1          return status;
 175   1      }


C51 COMPILER V9.60.7.0   MFRC522                                                           05/23/2025 10:22:55 PAGE 4   

MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    747    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      29
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
